#include "font-internal.h"
#include "stb_truetype.h"
#include <math.h>
#include <stdio.h>

/* converts 1bpp pixels generated by stbtt to 4bpp, applying the color value */
void fc_colorify(
    unsigned char * old_pixels,
    unsigned char * new_pixels,
    struct fc_size dimensions,
    struct fc_color color
) {
  unsigned char * src;
  unsigned char * dst;

  int i, j, w = (int) dimensions.width, h = (int) dimensions.height;

  for (j = 0; j < h; ++j) {
    src = old_pixels + j * w;
    dst = new_pixels + j * w * 4;
    for (i = w - 1; i >= 0; --i, src += 1, dst += 4) {
      dst[0] = color.r;
      dst[1] = color.g;
      dst[2] = color.b;
      dst[3] = src[0];
    }
  }
}

float fc_get_scale(struct fc_font const * font) {
  float scale;
  if (font->metadata.size.type == fc_size_type__pt) {
    scale = stbtt_ScaleForMappingEmToPixels(
        font->metadata.info,
        font->metadata.size.value
    );
  } else {
    scale = stbtt_ScaleForPixelHeight(
        font->metadata.info,
        font->metadata.size.value
    );
  }
  return scale;
}


float fc_get_kern(struct fc_font const * font, uint32_t ch1, uint32_t ch2) {
  return fc_get_scale(font) * (float) stbtt_GetCodepointKernAdvance(font->metadata.info, ch1, ch2);
}

stbtt_pack_range * fc_locate_block(struct fc_font const * font, uint32_t point) {
  for (size_t i = 0; i < font->packing.count; i++) {
    if (point >= (uint32_t) font->packing.blocks[i].first_unicode_codepoint_in_range &&
        point <= (uint32_t) font->packing.blocks[i].first_unicode_codepoint_in_range + font->packing.blocks[i].num_chars)
      return &font->packing.blocks[i];
  }
  return NULL;
}

/* http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2 */
unsigned long upper_power_of_two(unsigned long v) {
  v--;
  v |= v >> 1U;
  v |= v >> 2U;
  v |= v >> 4U;
  v |= v >> 8U;
  v |= v >> 16U;
  v++;
  return v;
}

struct fc_size fc_calculate_pixel_buffer_size(stbtt_pack_range * blocks, size_t block_count, float font_height) {
  size_t i;
  float expected_size = 0;
  for (i = 0; i < block_count; i++) {
    expected_size += (float)(blocks[i].num_chars);
  }
  expected_size *= font_height * font_height;
  struct fc_size size = {
      .width = (float) sqrt((double)upper_power_of_two((int) expected_size)),
      .height = size.width
  };
  return size;
}

void fc_generate_metrics(struct fc_font *font) {
  float scale = fc_get_scale(font);
  int ascent, descent, line_gap;
  font->metrics.scale = scale;
  stbtt_GetFontVMetrics(font->metadata.info, &ascent, &descent, &line_gap);
  font->metrics.ascent = (scale * (float) ascent);
  font->metrics.descent = (scale * (float) descent);
  font->metrics.line_gap = (scale * (float) line_gap);
  font->metrics.line_height = (float)(font->metrics.ascent - font->metrics.descent + font->metrics.line_gap);
}
